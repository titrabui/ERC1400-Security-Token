/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface FundIssuerInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "batchExecutePaymentsAsController"
      | "batchSettleOrders"
      | "canImplementInterfaceForAddress"
      | "canReceive"
      | "cancelOrder"
      | "executePaymentAsController"
      | "executePaymentAsInvestor"
      | "finalizeCycle"
      | "getAssetRules"
      | "getAssetValueRules"
      | "getCycle"
      | "getCycleAssetValue"
      | "getCycleOrders"
      | "getCycleState"
      | "getInvestorOrders"
      | "getLastCycleIndex"
      | "getNbCycles"
      | "getNbOrders"
      | "getOrder"
      | "getOrderAmountAndValue"
      | "getTotalSettledForCycle"
      | "priceOracles"
      | "rejectOrder"
      | "setAssetRules"
      | "setAssetValueRules"
      | "setPriceOracles"
      | "setTokenControllers"
      | "subscribe"
      | "tokenControllers"
      | "tokensReceived"
      | "valuate"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "batchExecutePaymentsAsController",
    values: [BigNumberish[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "batchSettleOrders",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canReceive",
    values: [
      BytesLike,
      BytesLike,
      AddressLike,
      AddressLike,
      AddressLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsController",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "executePaymentAsInvestor",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetRules",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetValueRules",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleAssetValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleOrders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCycleState",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getInvestorOrders",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastCycleIndex",
    values: [AddressLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getNbCycles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNbOrders",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getOrder",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getOrderAmountAndValue",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalSettledForCycle",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "priceOracles",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "rejectOrder",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetRules",
    values: [
      AddressLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      AddressLike,
      BytesLike,
      AddressLike,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetValueRules",
    values: [AddressLike, BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPriceOracles",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenControllers",
    values: [AddressLike, AddressLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "subscribe",
    values: [
      AddressLike,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenControllers",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensReceived",
    values: [
      BytesLike,
      BytesLike,
      AddressLike,
      AddressLike,
      AddressLike,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "valuate",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "batchExecutePaymentsAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchSettleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "canReceive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsController",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executePaymentAsInvestor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getCycle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCycleAssetValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCycleState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInvestorOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastCycleIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbCycles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNbOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOrderAmountAndValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalSettledForCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "priceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rejectOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetValueRules",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPriceOracles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "subscribe", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tokenControllers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "valuate", data: BytesLike): Result;
}

export interface FundIssuer extends BaseContract {
  connect(runner?: ContractRunner | null): FundIssuer;
  waitForDeployment(): Promise<this>;

  interface: FundIssuerInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  batchExecutePaymentsAsController: TypedContractMethod<
    [orderIndexes: BigNumberish[], bypassPayment: boolean],
    [void],
    "nonpayable"
  >;

  batchSettleOrders: TypedContractMethod<
    [orderIndexes: BigNumberish[]],
    [void],
    "nonpayable"
  >;

  canImplementInterfaceForAddress: TypedContractMethod<
    [interfaceHash: BytesLike, arg1: AddressLike],
    [string],
    "view"
  >;

  canReceive: TypedContractMethod<
    [
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: AddressLike,
      arg3: AddressLike,
      arg4: AddressLike,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike
    ],
    [boolean],
    "view"
  >;

  cancelOrder: TypedContractMethod<
    [orderIndex: BigNumberish],
    [void],
    "nonpayable"
  >;

  executePaymentAsController: TypedContractMethod<
    [orderIndex: BigNumberish, bypassPayment: boolean],
    [void],
    "nonpayable"
  >;

  executePaymentAsInvestor: TypedContractMethod<
    [orderIndex: BigNumberish],
    [void],
    "payable"
  >;

  finalizeCycle: TypedContractMethod<
    [cycleIndex: BigNumberish],
    [void],
    "nonpayable"
  >;

  getAssetRules: TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [[bigint, bigint, bigint, bigint, bigint, string, string, string, boolean]],
    "view"
  >;

  getAssetValueRules: TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [[bigint, bigint, bigint]],
    "view"
  >;

  getCycle: TypedContractMethod<
    [index: BigNumberish],
    [
      [
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        boolean
      ]
    ],
    "view"
  >;

  getCycleAssetValue: TypedContractMethod<
    [index: BigNumberish],
    [[bigint, bigint, bigint]],
    "view"
  >;

  getCycleOrders: TypedContractMethod<
    [index: BigNumberish],
    [bigint[]],
    "view"
  >;

  getCycleState: TypedContractMethod<
    [cycleIndex: BigNumberish],
    [bigint],
    "view"
  >;

  getInvestorOrders: TypedContractMethod<
    [investor: AddressLike],
    [bigint[]],
    "view"
  >;

  getLastCycleIndex: TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [bigint],
    "view"
  >;

  getNbCycles: TypedContractMethod<[], [bigint], "view">;

  getNbOrders: TypedContractMethod<[], [bigint], "view">;

  getOrder: TypedContractMethod<
    [index: BigNumberish],
    [[bigint, string, bigint, bigint, bigint, bigint]],
    "view"
  >;

  getOrderAmountAndValue: TypedContractMethod<
    [orderIndex: BigNumberish],
    [[bigint, bigint]],
    "view"
  >;

  getTotalSettledForCycle: TypedContractMethod<
    [cycleIndex: BigNumberish],
    [[bigint, bigint, boolean]],
    "view"
  >;

  priceOracles: TypedContractMethod<
    [tokenAddress: AddressLike],
    [string[]],
    "view"
  >;

  rejectOrder: TypedContractMethod<
    [orderIndex: BigNumberish, rejected: boolean],
    [void],
    "nonpayable"
  >;

  setAssetRules: TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: AddressLike,
      paymentPartition: BytesLike,
      fundAddress: AddressLike,
      subscriptionsOpened: boolean
    ],
    [void],
    "nonpayable"
  >;

  setAssetValueRules: TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  setPriceOracles: TypedContractMethod<
    [tokenAddress: AddressLike, oracles: AddressLike[]],
    [void],
    "nonpayable"
  >;

  setTokenControllers: TypedContractMethod<
    [tokenAddress: AddressLike, operators: AddressLike[]],
    [void],
    "nonpayable"
  >;

  subscribe: TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean
    ],
    [bigint],
    "payable"
  >;

  tokenControllers: TypedContractMethod<
    [tokenAddress: AddressLike],
    [string[]],
    "view"
  >;

  tokensReceived: TypedContractMethod<
    [
      arg0: BytesLike,
      partition: BytesLike,
      arg2: AddressLike,
      from: AddressLike,
      to: AddressLike,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike
    ],
    [void],
    "nonpayable"
  >;

  valuate: TypedContractMethod<
    [
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "batchExecutePaymentsAsController"
  ): TypedContractMethod<
    [orderIndexes: BigNumberish[], bypassPayment: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchSettleOrders"
  ): TypedContractMethod<[orderIndexes: BigNumberish[]], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "canImplementInterfaceForAddress"
  ): TypedContractMethod<
    [interfaceHash: BytesLike, arg1: AddressLike],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "canReceive"
  ): TypedContractMethod<
    [
      arg0: BytesLike,
      arg1: BytesLike,
      arg2: AddressLike,
      arg3: AddressLike,
      arg4: AddressLike,
      arg5: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike
    ],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "cancelOrder"
  ): TypedContractMethod<[orderIndex: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "executePaymentAsController"
  ): TypedContractMethod<
    [orderIndex: BigNumberish, bypassPayment: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "executePaymentAsInvestor"
  ): TypedContractMethod<[orderIndex: BigNumberish], [void], "payable">;
  getFunction(
    nameOrSignature: "finalizeCycle"
  ): TypedContractMethod<[cycleIndex: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "getAssetRules"
  ): TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [[bigint, bigint, bigint, bigint, bigint, string, string, string, boolean]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getAssetValueRules"
  ): TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [[bigint, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCycle"
  ): TypedContractMethod<
    [index: BigNumberish],
    [
      [
        string,
        string,
        bigint,
        bigint,
        bigint,
        bigint,
        bigint,
        string,
        string,
        boolean
      ]
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCycleAssetValue"
  ): TypedContractMethod<
    [index: BigNumberish],
    [[bigint, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCycleOrders"
  ): TypedContractMethod<[index: BigNumberish], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "getCycleState"
  ): TypedContractMethod<[cycleIndex: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getInvestorOrders"
  ): TypedContractMethod<[investor: AddressLike], [bigint[]], "view">;
  getFunction(
    nameOrSignature: "getLastCycleIndex"
  ): TypedContractMethod<
    [assetAddress: AddressLike, assetClass: BytesLike],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getNbCycles"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getNbOrders"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getOrder"
  ): TypedContractMethod<
    [index: BigNumberish],
    [[bigint, string, bigint, bigint, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOrderAmountAndValue"
  ): TypedContractMethod<
    [orderIndex: BigNumberish],
    [[bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTotalSettledForCycle"
  ): TypedContractMethod<
    [cycleIndex: BigNumberish],
    [[bigint, bigint, boolean]],
    "view"
  >;
  getFunction(
    nameOrSignature: "priceOracles"
  ): TypedContractMethod<[tokenAddress: AddressLike], [string[]], "view">;
  getFunction(
    nameOrSignature: "rejectOrder"
  ): TypedContractMethod<
    [orderIndex: BigNumberish, rejected: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setAssetRules"
  ): TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      firstStartTime: BigNumberish,
      subscriptionPeriodLength: BigNumberish,
      valuationPeriodLength: BigNumberish,
      paymentPeriodLength: BigNumberish,
      paymentType: BigNumberish,
      paymentAddress: AddressLike,
      paymentPartition: BytesLike,
      fundAddress: AddressLike,
      subscriptionsOpened: boolean
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setAssetValueRules"
  ): TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      assetValueType: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setPriceOracles"
  ): TypedContractMethod<
    [tokenAddress: AddressLike, oracles: AddressLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setTokenControllers"
  ): TypedContractMethod<
    [tokenAddress: AddressLike, operators: AddressLike[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "subscribe"
  ): TypedContractMethod<
    [
      assetAddress: AddressLike,
      assetClass: BytesLike,
      orderValue: BigNumberish,
      orderAmount: BigNumberish,
      orderType: BigNumberish,
      executePaymentAtSubscription: boolean
    ],
    [bigint],
    "payable"
  >;
  getFunction(
    nameOrSignature: "tokenControllers"
  ): TypedContractMethod<[tokenAddress: AddressLike], [string[]], "view">;
  getFunction(
    nameOrSignature: "tokensReceived"
  ): TypedContractMethod<
    [
      arg0: BytesLike,
      partition: BytesLike,
      arg2: AddressLike,
      from: AddressLike,
      to: AddressLike,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "valuate"
  ): TypedContractMethod<
    [
      cycleIndex: BigNumberish,
      assetValue: BigNumberish,
      reverseAssetValue: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  filters: {};
}
